<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[Ubuntu 连接远程服务器]]></title>
      <url>http://wususu.github.io/2016/07/28/Ubuntu-%E8%BF%9E%E6%8E%A5%E8%BF%9C%E7%A8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      <content type="html"><![CDATA[<ol>
<li>更新:<br> $sudo apt-get update</li>
<li>安装 ssh:<br> $sudo apt-get install openssh-server</li>
<li>启动ssh-server<br> $ /etc/init.d/ssh restart</li>
<li>确认工作:<br> $netstat -tlp<br> 看到 tcp6 0 0 <em>:ssh </em>:* LISTEN -  说明已运行</li>
<li>通过ssh登录服务器:<br> $ssh -l 用户名 IP<br> 回车之后输入密码</li>
</ol>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[python下使用Redis]]></title>
      <url>http://wususu.github.io/2016/07/21/python%E4%B8%8B%E4%BD%BF%E7%94%A8Redis/</url>
      <content type="html"></content>
    </entry>
    
    <entry>
      <title><![CDATA[DFA-确定有限状态自动机]]></title>
      <url>http://wususu.github.io/2016/07/19/DFA-%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA/</url>
      <content type="html"><![CDATA[<blockquote><p>确定有限状态自动机或确定有限自动机（英语：deterministic finite automation, DFA）是一个能实现状态转移的自动机对于一个给定的属于该自动机的状态和一个属于该自动机字母表 {\displaystyle \Sigma } \Sigma 的字符，它都能根据事先给定的转移函数转移到下一个状态（这个状态可以是先前那个状态）。</p>
<footer><strong>Wiki</strong><cite><a href="https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA" target="_blank" rel="external">zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA</a></cite></footer></blockquote>
<h3 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h3><p>  DFA的基本功能是可以通过event和当前的state得到下一个state，即event+state=nextstate,如下图所示,和数字逻辑电路的状态图类似:<br> <img src="/img/201607201.png" alt=""></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用:"></a>应用:</h3><p>  DFA引用很广,例如敏感词语的过滤,也就是常说的和谐,将敏感词语替换成”**”,这次的项目需求是判断文本是否有敏感词,以此划分权值.</p>
<h3 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路:"></a>实现思路:</h3><p>  1.将所有的敏感词语打包,建立一个字典树.<br>  2.依次遍历文本字符,进行判断</p>
<p> <strong>树结构:</strong></p>
<p><img src="/img/201607202.jpg" alt="结构图"></p>
<h3 id="代码"><a href="#代码" class="headerlink" title="代码:"></a>代码:</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class Node(object):</div><div class="line">    def __init__(self):</div><div class="line">        self.children = None</div><div class="line"></div><div class="line"># The encode of word is UTF-8</div><div class="line">class DFA():</div><div class="line">    def __init__(self):</div><div class="line">        self.root = Node()</div><div class="line">        self.keywords = []</div><div class="line"></div><div class="line">        path = &quot;keywords&quot;</div><div class="line">        fp = open(path,&apos;r&apos;)</div><div class="line">        for line in fp:</div><div class="line">            a = line[0:-1]</div><div class="line">            self.keywords.append(a)</div><div class="line">        print(self.keywords)</div><div class="line"></div><div class="line">    #构造敏感词字典树</div><div class="line">    def __add_word(self):</div><div class="line">        for word in self.keywords:</div><div class="line">            node = self.root</div><div class="line">            for i in range(len(word)):</div><div class="line">                if node.children == None:</div><div class="line">                    node.children = [&#123;&#125;,False]</div><div class="line">                    node.children[0][word[i]] = Node()</div><div class="line">                    node = node.children[0][word[i]]</div><div class="line">                    if i == len(word) - 1:</div><div class="line">                        node.children = [&#123;&#125;,True]</div><div class="line"></div><div class="line">                elif word[i] not in node.children[0].keys() and node.children!=None:</div><div class="line">                    node.children[0][word[i]] = Node()</div><div class="line">                    node = node.children[0][word[i]]</div><div class="line">                    if i == len(word) - 1 :</div><div class="line">                        node.children  = [&#123;&#125;, True]</div><div class="line">                else:</div><div class="line">                    node = node.children[0][word[i]]</div><div class="line">    </div><div class="line">    #查找敏感词</div><div class="line">    def search(self, message):</div><div class="line">        self.__add_word()</div><div class="line">        node = self.root</div><div class="line">        if node == None:</div><div class="line">            return</div><div class="line">        else:</div><div class="line">            i = j = 0</div><div class="line">            result = &apos;&apos;</div><div class="line">            while i &lt; len(message):</div><div class="line">                # print(message[i])</div><div class="line">                if node.children[1] == True:</div><div class="line">                    if result != &apos;的&apos;:     </div><div class="line">                        print(result)</div><div class="line">                    result = &apos;&apos;</div><div class="line">                    i = i - j + 1</div><div class="line">                    j = 0</div><div class="line">                if message[i] not in node.children[0].keys():</div><div class="line">                    # print(2)</div><div class="line">                    result = &apos;&apos;</div><div class="line">                    i = i - j + 1</div><div class="line">                    j = 0</div><div class="line">                elif message[i] in node.children[0].keys():</div><div class="line">                    # print(3)</div><div class="line">                    result = result + message[i]</div><div class="line">                    node = node.children[0][message[i]]</div><div class="line">                    j += 1</div><div class="line">                    i += 1</div><div class="line">                    continue</div><div class="line">                node = self.root</div><div class="line">        return</div><div class="line"></div><div class="line">if __name__ == &apos;__main__&apos;:</div><div class="line">    doc = &apos;&apos;   #测试文本</div><div class="line">    DFA().search(doc)</div><div class="line">    </div></pre></td></tr></table></figure>
<p>注: 代码还不是很好,等待完善,存在’的’问题,目前只能添加过滤条件的方式去除</p>
<h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献:"></a>参考文献:</h3><blockquote>
<p><a href="https://zh.wikipedia.org/wiki/%E7%A1%AE%E5%AE%9A%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E8%87%AA%E5%8A%A8%E6%9C%BA#DFA.E4.B8.8E.E6.9C.89.E5.90.91.E5.9B.BE" target="_blank" rel="external">维基百科</a><br><a href="http://ahuaxuan.iteye.com/blog/336577" target="_blank" rel="external">相关博文</a><br><a href="http://blog.sina.com.cn/s/blog_7eaa03930102w36z.html" target="_blank" rel="external">相关博文</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[基于Mojo-Weixin+图灵+python的微信机器人]]></title>
      <url>http://wususu.github.io/2016/07/17/%E5%9F%BA%E4%BA%8EMojo-Weixin-%E5%9B%BE%E7%81%B5-python%E7%9A%84%E5%BE%AE%E4%BF%A1%E6%9C%BA%E5%99%A8%E4%BA%BA-1/</url>
      <content type="html"><![CDATA[<h2 id="主要分为三个模块"><a href="#主要分为三个模块" class="headerlink" title="主要分为三个模块: "></a>主要分为三个模块: </h2><p>一.微信交互模块: 这里我直接使用Mojo-Wexin进行模拟登录与数据交互<br>二.智能聊天模块: 这里采用的是图灵机器人<br>三.数据的交互模块: 采用python编写的脚本处理数据进行前两个模块的交互</p>
<hr>
<h2 id="一-微信交互"><a href="#一-微信交互" class="headerlink" title="一.微信交互"></a>一.微信交互</h2><p>  通过API通讯,具体查阅文档<a href="https://github.com/sjdy521/Mojo-Weixin" target="_blank" rel="external">Mojo-Weixin</a></p>
<h2 id="二-智能聊天"><a href="#二-智能聊天" class="headerlink" title="二.智能聊天"></a>二.智能聊天</h2><h5 id="这里使用的是图灵机器人首先要注册一个帐号获取机器人钥匙-地址用于通讯-secret用于数据的加密-这里纯粹玩玩-就不用了-Mojo是通过模拟网页微信登录-所以要用API接入文档"><a href="#这里使用的是图灵机器人首先要注册一个帐号获取机器人钥匙-地址用于通讯-secret用于数据的加密-这里纯粹玩玩-就不用了-Mojo是通过模拟网页微信登录-所以要用API接入文档" class="headerlink" title="这里使用的是图灵机器人首先要注册一个帐号获取机器人钥匙,地址用于通讯,secret用于数据的加密(这里纯粹玩玩,就不用了),Mojo是通过模拟网页微信登录,所以要用API接入文档"></a>这里使用的是图灵机器人首先要注册一个帐号获取机器人钥匙,地址用于通讯,secret用于数据的加密(这里纯粹玩玩,就不用了),Mojo是通过模拟网页微信登录,所以要用API接入文档</h5><p> <img src="/img/tulin.jpg" alt="图灵key"></p>
<h2 id="三-数据交互"><a href="#三-数据交互" class="headerlink" title="三.数据交互"></a>三.数据交互</h2><h4 id="废话不多说-上代码"><a href="#废话不多说-上代码" class="headerlink" title="废话不多说,上代码"></a>废话不多说,上代码</h4><p> 1.<strong>与机器人交互的函数块</strong></p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line">def TuLin(say,userid):</div><div class="line">  msg = &#123;</div><div class="line">  &quot;key&quot;: &quot;图灵key&quot;,</div><div class="line">  &quot;info&quot;: say.encode(&apos;utf8&apos;),</div><div class="line">  &quot;userid&quot;: userid[2:]</div><div class="line">  &#125;</div><div class="line">  r = requests.post(url=&quot;访问地址&quot;,data=msg)</div><div class="line">  data = json.loads(r.text)</div><div class="line">  #聊天</div><div class="line">  if data[&apos;code&apos;] == 100000:</div><div class="line">      # print(data[&apos;text&apos;])</div><div class="line">      return data[&apos;text&apos;].replace(&apos;#&apos;,&apos;&apos;)</div><div class="line">  #新闻</div><div class="line">  elif data[&apos;code&apos;] == 302000:</div><div class="line">      xw_data = &apos;&apos;</div><div class="line">      s=0</div><div class="line">      print(data[&apos;text&apos;],data[&apos;list&apos;])</div><div class="line">      for xinwen in data[&apos;list&apos;]:</div><div class="line">          s+=1</div><div class="line">          xw_url  re.match(re.compile(u&apos;(^http://(.+)\.html)&apos;),xinwen[&apos;detailurl&apos;])</div><div class="line">          xw_url = xw_url.group(0)</div><div class="line">          xw_data = xw_data+&apos;\n&apos;+str(s)+&apos;、&apos;+ xinwen[&apos;article&apos;]+xw_url</div><div class="line">      return xw_data.replace(&apos;#&apos;,&apos;&apos;)</div><div class="line"></div></pre></td></tr></table></figure>
<p> 注意,发送文本字段若包含”#”,微信会自动过滤它及其后面的字段,这里我用 replace() 替换掉, 不同的返回码代表不同的类型,这里省去了部分代码</p>
<p>2.<strong>微信消息接收</strong></p>
<p>   使用flask模块监听Mojo-Weixin上报消息接口,接收群聊消息<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">@app.route(&apos;/receive_message&apos;, methods=[&apos;POST&apos;])</div><div class="line">def Receive():</div><div class="line">    data = request.json</div><div class="line">    print(data)</div><div class="line">    #群消息交互</div><div class="line">    if GetValue(&quot;group&quot;,data) != False and robot_name in GetValue(&apos;content&apos;,data):</div><div class="line">        Group_contact(data)</div><div class="line">    return &apos;1&apos;</div></pre></td></tr></table></figure></p>
<p> 3.<strong>微信消息发送</strong><br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def Send(msg, g_id, sender_name):  </div><div class="line">    data = &apos;@&apos;+sender_name +&apos;\u2005\n&apos;+ str(msg)</div><div class="line">    url = WxG_url+&apos;send_group_message?id=&apos;+g_id+ &apos;&amp;content=&apos;+data</div><div class="line">    print(&apos;url:&apos;,data)</div><div class="line">    r = requests.get(url).json()</div><div class="line">    if r[&apos;code&apos;] != 0:</div><div class="line">        print(&apos;发送失败&apos;)</div><div class="line">        return False</div><div class="line">    return True</div></pre></td></tr></table></figure></p>
<p>  4.<strong>控制模块</strong><br>   控制模块起到了中介作用传递数据,在这里可以对数据进行筛选自定义,打造自己需要的功能.例如:通过聊天关键字’海贼王漫画’,机器人自动发送最新一集漫画链接..是不是很强大呢.<br>   注: GetValue 提取数据中对应键的值<br>   <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">def Group_contact(data):</div><div class="line">  content = GetValue(&apos;content&apos;, data)</div><div class="line">  sender_id = GetValue(&apos;sender_id&apos;, data)</div><div class="line">  sender_name = GetValue(&apos;sender&apos;, data)</div><div class="line">  group_id = GetValue(&apos;group_id&apos;, data)</div><div class="line">  print(content)</div><div class="line">  msg = content.lstrip(robot_name)</div><div class="line">  if msg == &apos;刷屏&apos;:</div><div class="line">      Send(beauty, group_id, sender_name)</div><div class="line">  else:</div><div class="line">      if msg == &apos;&apos;:</div><div class="line">          msg = &apos;几点了&apos;</div><div class="line">      print(TuLin(msg, sender_id))</div><div class="line">      Send(TuLin(msg, sender_id), group_id, sender_name)</div><div class="line">  return True</div></pre></td></tr></table></figure></p>
<h2 id="效果图"><a href="#效果图" class="headerlink" title="效果图"></a>效果图</h2><h5 id="目前功能包括智能聊天-报时-看新闻-查菜谱-查列车航班-一-刷屏-好友自助加群-成语接龙-笑话-百科-新成员加群自动欢迎…更多功能待开发"><a href="#目前功能包括智能聊天-报时-看新闻-查菜谱-查列车航班-一-刷屏-好友自助加群-成语接龙-笑话-百科-新成员加群自动欢迎…更多功能待开发" class="headerlink" title="目前功能包括智能聊天,报时,看新闻,查菜谱,查列车航班,一@刷屏,好友自助加群,成语接龙,笑话,百科,新成员加群自动欢迎…更多功能待开发"></a>目前功能包括智能聊天,报时,看新闻,查菜谱,查列车航班,一@刷屏,好友自助加群,成语接龙,笑话,百科,新成员加群自动欢迎…更多功能待开发</h5><p> <img src="/img/201607181.jpg" width="330" height="500" alt="刷屏" align="center"><br> <img src="/img/201607182.jpg" width="330" height="500" alt="报时 查快递" align="center"><br> <img src="/img/201607183.jpg" width="330" height="500" alt="菜谱 成语接龙" align="center"><br> <img src="/img/201607184.jpg" width="330" height="500" alt="智能聊天" align="center"><br> <img src="/img/201607185.jpg" width="330" height="500" alt="看新闻" align="center"><br> <img src="/img/201607186.jpg" width="330" height="500" alt="好友自助进群" align="center"><br> <img src="/img/201607187.jpg" width="330" height="500" alt="查询列车航班" align="center"></p>
<blockquote>
<p>相关文献:<br>图灵API: <a href="https://github.com/sjdy521/Mojo-Weixin/blob/master/API.md" target="_blank" rel="external">API接入文档</a><br>微信接口: <a href="http://www.tuling123.com/html/doc/api.html" target="_blank" rel="external">Mojo-Weixin</a></p>
</blockquote>
]]></content>
    </entry>
    
    <entry>
      <title><![CDATA[BeautifulSoup 整理]]></title>
      <url>http://wususu.github.io/2016/07/14/2016-07-14-BeautifulSoup-%E6%95%B4%E7%90%86/</url>
      <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介:"></a>简介:</h1><p> Beautiful Soup 是一个可以从HTML或XML文件中提取数据的Python库.<br> 它能够通过你喜欢的转换器实现惯用的文档导航,查找,修改文档的方式.<br> 简单说就是利用bs4”美化”HTML,定位HTML标签来获得目标数据,实乃爬虫一大利器.</p>
<h1 id="属性"><a href="#属性" class="headerlink" title="属性:"></a>属性:</h1><p> <strong>1. Tag</strong><br>soup.+tag_name  可以多次调用<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eg:  soup.head</div><div class="line">	<span class="comment"># &lt;head&gt;&lt;title&gt;The Dormouse's story&lt;/title&gt;&lt;/head&gt;</span></div><div class="line">        soup.body.b</div><div class="line">	<span class="comment"># &lt;b&gt;The Dormouse's story&lt;/b&gt;</span></div></pre></td></tr></table></figure><br>  重命名一个tag,改变属性的值,添加或删除属性:<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">eg:  soup = BeautifulSoup(<span class="string">'&lt;b class="boldest"&gt;Extremely bold&lt;/b&gt;'</span>)</div><div class="line">	tag = soup.b</div><div class="line"></div><div class="line">	tag.name = <span class="string">"blockquote"</span></div><div class="line">	tag[<span class="string">'class'</span>] = <span class="string">'verybold'</span></div><div class="line">	tag[<span class="string">'id'</span>] = <span class="number">1</span></div><div class="line">	<span class="comment"># &lt;blockquote class="verybold" id="1"&gt;Extremely bold&lt;/blockquote&gt;</span></div><div class="line"></div><div class="line">	<span class="keyword">del</span> tag[<span class="string">'class'</span>]</div><div class="line">	<span class="keyword">del</span> tag[<span class="string">'id'</span>]</div><div class="line">	<span class="comment"># &lt;blockquote&gt;Extremely bold&lt;/blockquote&gt;</span></div></pre></td></tr></table></figure></p>
<p> <strong>3. 属性</strong><br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eg:  tag.attrs</div><div class="line">	<span class="comment">#[''class', 'blodest']</span></div><div class="line">	tag[<span class="string">'属性名字'</span>]</div><div class="line">   </div></pre></td></tr></table></figure></p>
<p> <strong>2. 子孙</strong><br> .contents 属性可以将tag的子节点以列表的方式输出:<br> .children 生成器,可以对tag的子节点进行循环:<br> .descendants   获得子孙节点</p>
<p> <strong>4. 父辈</strong><br> .parent  获取某个元素的父节点<br> .parents  可以递归得到元素的所有父辈节点</p>
<p><strong>5.  文本内容</strong><br> .string  tag仅有一个子或者没有节点.string 方法返回字符串<br>.strings  tag中包含多个字符串 [2] ,可以使用 .strings 来循环获取<br>.stripped_strings  除多余空白内容的方法</p>
<p>  修改 .string:<br>给tag的 .string 属性赋值,可以替代原来的内容<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">eg:  markup = <span class="string">'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></div><div class="line">	soup = BeautifulSoup(markup)</div><div class="line"></div><div class="line">	tag = soup.a</div><div class="line">	tag.string = <span class="string">"New link text."</span></div><div class="line">	<span class="comment"># &lt;a href="http://example.com/"&gt;New link text.&lt;/a&gt;</span></div></pre></td></tr></table></figure></p>
<h1 id="一些有用的方法"><a href="#一些有用的方法" class="headerlink" title="一些有用的方法"></a>一些有用的方法</h1><p> <strong>1.  append()</strong><br>  向标签中添加内容:<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">eg:  soup = BeautifulSoup(<span class="string">"&lt;a&gt;Foo&lt;/a&gt;"</span>)</div><div class="line">	soup.a.append(<span class="string">"Bar"</span>)</div><div class="line"></div><div class="line">	soup</div><div class="line">	<span class="comment"># &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a&gt;FooBar&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;</span></div><div class="line">	soup.a.contents</div><div class="line">	<span class="comment"># [u'Foo', u'Bar'</span></div><div class="line">	</div></pre></td></tr></table></figure></p>
<p> <strong>2. new_string() 和 new_tag()</strong><br>  如果想要创建一段注释,或 NavigableString 的任何子类,将子类作为 new_string() 方法的第二个参数传入:<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">eg:  <span class="keyword">from</span> bs4 <span class="keyword">import</span> Comment</div><div class="line">	new_comment = soup.new_string(<span class="string">"Nice to see you."</span>, Comment)</div><div class="line">	tag.append(new_comment)</div><div class="line">	<span class="comment"># &lt;b&gt;Hello there&lt;!--Nice to see you.--&gt;&lt;/b&gt;</span></div><div class="line">	tag.contents</div><div class="line">	<span class="comment"># [u'Hello', u' there', u'Nice to see you.']</span></div><div class="line">	</div></pre></td></tr></table></figure><br>创建一个tag最好的方法是调用工厂方法 BeautifulSoup.new_tag() :<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">eg:  soup = BeautifulSoup(<span class="string">"&lt;b&gt;&lt;/b&gt;"</span>)</div><div class="line">	original_tag = soup.b</div><div class="line"></div><div class="line">	new_tag = soup.new_tag(<span class="string">"a"</span>, href=<span class="string">"http://www.example.com"</span>)</div><div class="line">	original_tag.append(new_tag)</div><div class="line">	original_tag</div><div class="line">	<span class="comment"># &lt;b&gt;&lt;a href="http://www.example.com"&gt;&lt;/a&gt;&lt;/b&gt;</span></div><div class="line"></div><div class="line">	new_tag.string = <span class="string">"Link text."</span></div><div class="line">	original_tag</div><div class="line">	<span class="comment"># &lt;b&gt;&lt;a href="http://www.example.com"&gt;Link text.&lt;/a&gt;&lt;/b&gt;</span></div><div class="line">		</div></pre></td></tr></table></figure><br> <strong>3. insert()</strong><br>与append() 类似, 不过可以指定位置<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eg:  tag.insert(<span class="number">1</span>, <span class="string">"but did not endorse "</span>)</div><div class="line">	<span class="comment"># &lt;a href="http://example.com/"&gt;I linked to but did not endorse &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;</span></div><div class="line">	tag.contents</div><div class="line">	<span class="comment"># [u'I linked to ', u'but did not endorse', &lt;i&gt;example.com&lt;/i&gt;]</span></div></pre></td></tr></table></figure></p>
<h1 id="搜索"><a href="#搜索" class="headerlink" title="搜索:"></a>搜索:</h1><p> <strong>1. find_all(self, name, attrs, recursive, text,  limit, kwargs )</strong><br>    查找符合匹配的标签,返回一个list</p>
<p>   a. name:   参数的值可以使任一类型的: ,字符串,正则表达式,列表,方法或是 True .<br>   字符串:<br> 查找所有 “name” 标签<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eg:  soup.find_all(<span class="string">'title'</span>)</div><div class="line">    <span class="comment">#[&lt;title&gt;广州兼职工作-兼职吧&lt;/title&gt;] </span></div></pre></td></tr></table></figure><br> 正则表达式:<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eg:   soup.find_all(re.compile(<span class="string">'ti[a-z]&#123;2&#125;e'</span>))</div><div class="line">    <span class="comment">#[&lt;title&gt;广州兼职工作-兼职吧&lt;/title&gt;]</span></div></pre></td></tr></table></figure><br>  列表: 只要与列表任一元素匹配,就返回<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eg:  soup.find_all([<span class="string">'head'</span>, <span class="string">'a'</span>, re.compile(<span class="string">'ti[a-z]&#123;2&#125;e'</span>)])</div><div class="line">     <span class="comment">#[&lt;title&gt;广州兼职工作-兼职吧&lt;/title&gt;, &lt;a href="/" style="margin-left:8px;margin-right:2px;font-size:15px;" target="_blank"&gt;&lt;/a&gt;]</span></div></pre></td></tr></table></figure><br>  方法: 自定义过滤方法, 正确的返回true<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eg:  <span class="function"><span class="keyword">def</span> <span class="title">aa</span><span class="params">(tag)</span>:</span></div><div class="line">    		<span class="keyword">if</span> tag.has_attr(<span class="string">'href'</span>):</div><div class="line">        		<span class="keyword">return</span> true</div><div class="line">        soup.find_all(aa)</div><div class="line">     <span class="comment">#[&lt;link href="http://www.jianzhi8.com/comcity",...]</span></div></pre></td></tr></table></figure></p>
<p>   b. keyword参数(官方文档有,但是pycharm没显示这个参数,不解), 搜索每个属性和属性值匹配的标签:<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eg:  soup.find_all(id = <span class="string">'link2'</span>)</div><div class="line">	<span class="comment">#[&lt;a class="sister" href="http://example.com/lacie" id="link2"&gt;Lacie&lt;/a&gt;]</span></div></pre></td></tr></table></figure><br>  可以指定多个匹配属性:<br>    <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eg:  soup.find_all(href=re.compile(<span class="string">"elsie"</span>), id=<span class="string">'link1'</span>)</div><div class="line">	<span class="comment"># [&lt;a class="sister" href="http://example.com/elsie" id="link1"&gt;three&lt;/a&gt;]</span></div></pre></td></tr></table></figure><br>同样,参数值可以是 字符串 , 正则表达式 , 列表, True .</p>
<p>   c. recursive:  默认为true, Beautiful Soup会检索当前标签的所有子孙节点,如果只想搜索标签的直接子节点,可以使用 recursive=False<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eg: soup.find_all(<span class="string">"title"</span>, recursive = <span class="keyword">False</span>)</div><div class="line">	<span class="comment">#[]</span></div><div class="line">	soup.find_all(<span class="string">"html"</span>, recursive = <span class="keyword">True</span>)</div><div class="line">	<span class="comment">#&lt;html&gt;&lt;head&gt;&lt;title&gt;......&lt;/html&gt;</span></div><div class="line">	</div></pre></td></tr></table></figure></p>
<p>   d. text: 搜索文档中的字符串内容(文本内容).与 name 参数的可选值一样, text 参数接受 字符串 , 正则表达式 , 列表, 函数, True<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line">eg: soup.find_all(text=<span class="string">"Elsie"</span>)</div><div class="line">	<span class="comment"># [u'Elsie']</span></div><div class="line"></div><div class="line">       soup.find_all(text=[<span class="string">"Tillie"</span>, <span class="string">"Elsie"</span>, <span class="string">"Lacie"</span>])</div><div class="line">	<span class="comment"># [u'Elsie', u'Lacie', u'Tillie']</span></div><div class="line"></div><div class="line">       soup.find_all(text=re.compile(<span class="string">"Dormouse"</span>))</div><div class="line">	<span class="comment">#[u"The Dormouse's story", u"The Dormouse's story"]</span></div><div class="line"></div><div class="line">       <span class="function"><span class="keyword">def</span> <span class="title">is_the_only_string_within_a_tag</span><span class="params">(s)</span>:</span></div><div class="line">       		Return <span class="keyword">True</span> <span class="keyword">if</span> this string <span class="keyword">is</span> the only child of its parent tag.<span class="string">""</span></div><div class="line">       		<span class="keyword">return</span> (s == s.parent.string)</div><div class="line"></div><div class="line">   	soup.find_all(text=is_the_only_string_within_a_tag)</div><div class="line">	<span class="comment"># [u"The Dormouse's story", u"The Dormouse's story", u'Elsie', u'Lacie', u'Tillie', u'...']</span></div><div class="line">	</div></pre></td></tr></table></figure></p>
<p>   e. limit: 限制返回结果的数量.当搜索到的结果数量达到 limit 的限制时,停止返回</p>
<p>  f. attrs :参数定义一个字典参数来搜索包含属性的标签, 与keyword效果相似,不过两种都有不能搜索的属性, 混着用, 效果更加哟<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">eg: soup.find_all(attrs=&#123;<span class="string">"type"</span>:<span class="string">"text"</span>&#125;)</div><div class="line">	<span class="comment">#[&lt;input class="sr_btn" id="s_key" name="s_key" type="text" value=""/&gt;]</span></div><div class="line"> </div></pre></td></tr></table></figure></p>
<p>   g. 按照css搜索, 其实就是 keyword 搜索时键为class时的特殊情况<br> // tip: CSS类名的关键字 class 在Python中是保留字,使用 class 做参数会导致语法错误.从Beautiful Soup的4.1.1版本开始,可以通过 class_ 参数搜索有指定CSS类名的tag<br>     class 属性是 多值属性(一个tag可以有多个CSS的class) .按照CSS类名搜索tag时,可以分别搜索tag中的每个CSS类名:<br>       <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">eg:   css_soup = BeautifulSoup(<span class="string">'&lt;p class="body strikeout"&gt;&lt;/p&gt;'</span>)</div><div class="line">	 css_soup.find_all(<span class="string">"p"</span>, class_=<span class="string">"strikeout"</span>)</div><div class="line">	<span class="comment"># [&lt;p class="body strikeout"&gt;&lt;/p&gt;]</span></div><div class="line">	</div></pre></td></tr></table></figure></p>
<p>   h. 官方doc大概就是说find_all()太常用了, 你们直接用Beautiful对象就可以调用方法.感觉没什么用,反而增加了阅读源码的难度<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">eg:  soup.find_all(<span class="string">"a"</span>)  &lt;==&gt;  soup(<span class="string">"a"</span>)</div></pre></td></tr></table></figure></p>
<p> <strong>2. find( name , attrs , recursive , text , </strong>kwargs )**<br>  只返回一个搜索结果(limit = 1 的情况), 匹配不到返回None, 其余与find_all()大同小异</p>
<p> <strong>3. find_parents( name , attrs , recursive , text , </strong>kwargs ) 和 find_parent( name , attrs , recursive , text , <strong>kwargs )</strong><br>  find_all() find() 搜索当前节点的子孙节点. 而这两个搜索当前节点的父辈节点.<br>  parent 搜索到最近一个匹配的, 以金字塔形式由上(匹配处)至下(当前及其兄弟标签)返回所有标签<br>  parents 上面的全部匹配点, 同理</p>
<p> <strong>4. find_next_siblings()  find_next_sibling() 和 find_previous_siblings() find_previous_sibling()</strong><br>  顾名思义,返回前面和后面的兄弟标签</p>
<p> <strong>5. find_all_next()  find_next() 和 find_all_previous()  find_previous()</strong><br>  返回之前和之后的标签</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p> <strong>1. 格式化输出:  </strong><br>prettify() 方法将Beautiful Soup的文档树格式化后以Unicode编码输出,每个XML/HTML标签都独占一行<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">eg:  soup.prettify()</div><div class="line">	<span class="comment"># '&lt;html&gt;\n &lt;head&gt;\n &lt;/head&gt;\n &lt;body&gt;\n  &lt;a href="http://example.com/"&gt;\n... '</span></div></pre></td></tr></table></figure></p>
<p> <strong>2. 压缩输出:</strong><br> 只要字符串,不重视格式,那么可以对一个 BeautifulSoup 对象或 Tag 对象使用Python的 unicode() 或 str() 方法:<br>   <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eg:  str(soup)</div><div class="line">	<span class="comment"># '&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;&lt;/body&gt;&lt;/html&gt;'</span></div><div class="line"></div><div class="line">	unicode(soup.a)</div><div class="line">	<span class="comment"># u'&lt;a href="http://example.com/"&gt;I linked to &lt;i&gt;example.com&lt;/i&gt;&lt;/a&gt;'</span></div></pre></td></tr></table></figure></p>
<p> <strong>3. get_text()</strong><br> 只想得到tag中包含的文本内容,用 get_text() 方法,获取到tag中包含的所有文版内容包括子孙tag中的内容,并将结果作为Unicode字符串返回:<br>可以通过参数指定tag的文本内容的分隔符:<br>  <figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">eg:  soup.get_text(<span class="string">"|"</span>)</div><div class="line">	<span class="comment">#u'\nI linked to |example.com|\n'</span></div><div class="line">去除获得文本内容的前后空白:</div><div class="line">eg:  soup.get_text(<span class="string">"|"</span>, strip=<span class="keyword">True</span>)</div><div class="line">	<span class="comment">#u'I linked to|example.com' 	</span></div></pre></td></tr></table></figure></p>
<blockquote>
<p>参考文献:</p>
<ul>
<li><a href="https://www.crummy.com/software/BeautifulSoup/bs4/doc/index.zh.html" target="_blank" rel="external">官方文档</a><br>2016/07/13 23:41:36</li>
</ul>
</blockquote>
]]></content>
    </entry>
    
  
  
</search>
